# Menggunakan Object di Move

Sebelumnya kita telah membuat dan mentransfer object. Sekarang fokus: bagaimana cara memakai (mengoperasikan) object tersebut.

Di Sui, hanya pemilik object yang boleh memanggilnya dalam transaksi. Object bisa diteruskan ke fungsi `public entry` dengan dua cara: by reference dan by value.

## Pass by Reference

Variasi referensi:
1. `&T`  : read-only (tidak bisa ubah isi)
2. `&mut T` : mutable (boleh ubah field)

`T` adalah tipe object; tanda `&` menunjukkan passing by reference.

### Read-only Reference

Hanya boleh baca field. Contoh:

```move
module sum::sum {

    public struct SumObject has key { id: UID, number_1: u8, number_2: u8 }

    public fun new(a: u8, b: u8, ctx: &mut TxContext): SumObject {
        SumObject { id: object::new(ctx), number_1: a, number_2: b }
    }

    entry fun make_copy(obj: &SumObject, ctx: &mut TxContext) {
        let clone = new(obj.number_1, obj.number_2, ctx);
        transfer::transfer(clone, tx_context::sender(ctx));
    }
}
```

### Mutable Reference

Memungkinkan modifikasi field:

```move
module sum::sum {

    public struct SumObject has key { id: UID, number_1: u8, number_2: u8 }

    public entry public fun copy_into(src: &SumObject, dst: &mut SumObject, ctx: &mut TxContext) {
        dst.number_1 = src.number_1;
        dst.number_2 = src.number_2;
        transfer::transfer(dst, tx_context::sender(ctx));
    }
}
```

Pastikan pengirim transaksi (signer) memang pemilik kedua object.

## Pass by Value

Kita mengalihkan kepemilikan object ke public fungsi. Contoh:

```move
module sum::sum {
    public struct SumObject has key { id: UID, number_1: u8, number_2: u8 }

    public entry public fun update_num_1(new_val: u8, object: SumObject): SumObject {
        let mut_obj = object; // kepemilikan pindah
        mut_obj.number_1 = new_val;
        mut_obj
    }
}
```

Konsekuensi: instance baru perlu dikelola. Kita tidak bisa sembarang drop UID (tidak ada ability `drop`). Dua opsi penanganan: hapus (destroy) atau transfer.

### Menghapus Object (Destroy)

Harus di-unpack. Misal kita ingin menghapus `SumObject`:

```move
let SumObject { id, number_1: _, number_2: _ } = object;
object::delete(id);
```

Contoh lengkap (diperbaiki dari typo asal):

```move
module sum::sum {

    public struct SumObject has key { id: UID, number_1: u8, number_2: u8 }

    entry fun delete(obj: SumObject) {
        let SumObject { id, number_1: _, number_2: _ } = obj;
        object::delete(id);
    }
}
```

Hanya lakukan pada objek yang diterima by value (bukan referensi) agar tidak memusnahkan object global secara tak disengaja.

### Transfer Object

Alternatifnya, transfer ke pemilik lain:

```move
entry fun transfer_obj(obj: SumObject, recipient: address) {
    transfer::transfer(obj, recipient);
}
```

`recipient` adalah alamat penerima baru.

## Penutup

Kamu kini menguasai cara memakai object: read-only vs mutable reference, pass by value, destroy, dan transfer. Berikutnya kita bahas model kepemilikan (ownership) lebih detail.