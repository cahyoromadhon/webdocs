# Object Wrapping

Kamu sudah sampai jauh di kursus ini—mantap! Setelah memahami dasar dan membedah Hello World, saatnya masuk topik lebih lanjut. Di pelajaran ini kita bahas object wrapping, teknik penting saat membangun dApp di Sui.

## Apa itu Object Wrapping?

Di Sui Move, kita bisa menaruh sebuah Sui object di dalam object lain—ibarat toolbox berisi item di dalamnya. Secara teknis: menaruh field bertipe `struct` ke dalam `struct` lain.

```
struct Foo has key {
    id: UID,
    bar: Bar,
}

struct Bar has key, store {
    id: UID,
    value: u64,
}
```

Agar `struct` menjadi Sui object, ia harus punya ability `key`. Jika `Foo` (Sui object) menyimpan field bertipe `Bar` (Sui object), maka `Foo` membungkus `Bar`—`Foo` disebut wrapper.

Catatan penting:
- Menaruh Sui object ke dalam non-Sui struct hanya bersifat sementara (tidak persisten on-chain).
- Objek yang ter-wrap menjadi bagian data wrapper: tidak bisa dicari via UID-nya langsung dan tidak bisa dipass terpisah dalam transaksi—aksesnya lewat wrapper.
- Jangan membuat siklus wrapping (A membungkus B, B membungkus C, C membungkus A).
- Objek bisa di-unwrap kembali menjadi entitas independen dengan UID yang sama seperti sebelum dibungkus.

There are a few common ways to wrap a Sui object into another Sui object. Let’s look at them below:

### Direct Wrapping

If you put a Sui object type directly as a field in another Sui object type, it is called **direct wrapping**. In this type of wrapping, the wrapped object cannot be unwrapped unless the wrapping object is destroyed. It could be used to lock objects with limited access.

Contoh: anggap ada object gaya NFT bernama `Object` dengan `scarcity` dan `style`. Untuk fair trade, kita ingin hanya `style` yang beda sementara `scarcity` harus sama.

```
struct Object has key, store {
    id: UID,
    scarcity: u8,
    style: u8,
}

public entry fun create_object(scarcity: u8, style: u8, ctx: &mut TxContext) {
    let object = Object {
        id: object::new(ctx),
        scarcity,
        style,
    };
    transfer::transfer(object, tx_context::sender(ctx));
}
```

Dengan `create_object`, siapa pun bisa mencetak object dan mengirimkannya ke pengirim transaksi.

Hanya pemilik yang boleh memutasi object. Untuk swap, biasanya objek dikirim ke pihak ketiga (service). Agar kustodi tetap aman (service tidak bisa mencuri), gunakan direct wrapping:

```
struct ObjectWrapper has key {
    id: UID,
    original_owner: address,
    to_swap: Object,
    fee: Balance<SUI>,
}
```

`ObjectWrapper` membungkus object yang hendak ditukar (`to_swap`) dan mencatat pemilik asal. Ada juga field `fee`.

To request a swap, you define an entry function:

```
public entry fun request_swap(object: Object, fee: Coin<SUI>, service_address: address, ctx: &mut TxContext) {
    assert!(coin::value(&fee) >= MIN_FEE, 0);
    let wrapper = ObjectWrapper {
        id: object::new(ctx),
        original_owner: tx_context::sender(ctx),
        to_swap: object,
        fee: coin::into_balance(fee),
    };
    transfer::transfer(wrapper, service_address);
}
```

Fungsi tersebut membungkus object beserta fee dan mengirim wrapper ke alamat service.

Poin krusial: meski service memegang `ObjectWrapper`, ia tidak bisa mengakses/mengambil `Object` di dalamnya tanpa fungsi unwrapping yang spesifik—dan fungsi itu tidak disediakan di module ini.

### Wrapping via `Option`

In the Direct wrapping example above you had to destroy an object to get the one inside it out. But sometimes, you might want more flexibility, where the wrapping type doesn't always have the wrapped object inside it, and you can replace the wrapped object with a different one when needed.

Contoh: seorang warrior bisa punya atau tidak punya `sword`/`shield`, dan dapat mengganti peralatannya.

In the code below, we define a `SimpleWarrior` type with optional `sword` and `shield` fields. The `sword` and `shield` are other Sui object types.

```
struct SimpleWarrior has key {
    id: UID,
    sword: Option<Sword>,
    shield: Option<Shield>,
}

struct Sword has key, store {
    id: UID,
    strength: u8,
}

struct Shield has key, store {
    id: UID,
    armor: u8,
}
```

When you create a new warrior, you start with no equipment:

```
public entry fun create_warrior(ctx: &mut TxContext) {
    let warrior = SimpleWarrior {
        id: object::new(ctx),
        sword: option::none(),
        shield: option::none(),
    };
    transfer::transfer(warrior, tx_context::sender(ctx))
}
```

Fungsi `create_warrior` membuat warrior tanpa peralatan.

To equip a new sword or shield, you can define functions like below:

```
public entry fun equip_sword(warrior: &mut SimpleWarrior, sword: Sword, ctx: &mut TxContext) {
    if (option::is_some(&warrior.sword)) {
        let old_sword = option::extract(&mut warrior.sword);
        transfer::transfer(old_sword, tx_context::sender(ctx));
    };
    option::fill(&mut warrior.sword, sword);
}
```

Pada `equip_sword`, jika sudah ada pedang, keluarkan dulu dan kembalikan ke pengirim, lalu isi dengan pedang baru. Jadi peralatan bisa diganti dinamis.

## Wrapping via `vector`

In Sui, you can wrap objects in a vector field of another Sui object, which is similar to wrapping objects using the `Option` type. This approach allows an object to contain zero, one, or many wrapped objects of the same type.

Let’s consider an example involving pets and a farm:

```
struct Pet has key, store {
    id: UID,
    cuteness: u64,
}

struct Farm has key {
    id: UID,
    pets: vector<Pet>,
}
```

In this code, we have two object types:

1. `Pet`: Represents individual pets and has a unique ID and a "cuteness" value, which is just a placeholder for the pet's characteristics.
2. `Farm`: Represents a farm and has a unique ID as well. The key feature here is the `pets` field, which is a vector of `Pet` objects. This means a farm can contain multiple pets.

Dengan ini, satu farm bisa menampung banyak `Pet` di field `pets`.

## Penutup

Kamu sudah memahami konsep wrapping: direct, via `Option`, dan via `vector`. Berikutnya kita pelajari event di Move on Sui.