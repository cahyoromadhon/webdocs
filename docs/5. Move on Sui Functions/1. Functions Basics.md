# Dasar Fungsi (Functions Basics)

Setelah memahami dasar bahasa Sui Move, sekarang kita fokus ke cara kerja fungsi (function).

## Definisi Fungsi

Eksekusi logika terjadi di dalam fungsi. Kita mendefinisikan fungsi dengan keyword `fun`. Conpublic structor (seperti `init`) juga memakai `fun`. Bentuk paling sederhana:

```
public fun function_name() {
	// kode fungsi
}
```

Tidak ada parameter dan tidak ada nilai balik.

## Fungsi di dalam Module

Semua kode ditulis di dalam `module`. Contoh:

```
module examples::example {
	public fun add(num_1: u64, num_2: u64) {
		let sum = num_1 + num_2;
	}
}
```

Fungsi `add` hanya menjumlahkan dua argumen tanpa mengembalikan nilai.

## Argumen Fungsi

Format parameter: `nama: tipe`. Bisa tanpa argumen atau banyak argumen dipisah koma.

```
module examples::example {
	public fun function_name(argument_1: u8, argument_2: u8) {
		// kode
	}
}
```

Catatan:
1. Argumen dipisahkan koma.
2. Semua berada di dalam tanda kurung `()`.

Ruang hidup (lifetime) argumen hanya selama eksekusi fungsi.

## Return

Untuk mendefinisikan tipe nilai balik, tulis setelah tanda kurung: `fun nama(): tipe {}`.

```
module examples::example {
	public fun function_name(a: u8, b: u8): u8 {
		// ekspresi akhir jadi nilai balik
		a + b
	}
}
```

Di Move kita tidak wajib menulis keyword `return` untuk nilai terakhir; cukup letakkan ekspresi terakhir.

Contoh lain:

```
module math::math {
	public fun sum(a: u8, b: u8): u8 { a + b }
}
```

Mengembalikan object:

```
module examples::strings {
	use std::string::{Self, String};

	public struct Name has key { id: UID, name: String }

	public fun fill_name(name_bytes: vector<u8>, ctx: &mut TxContext): Name {
		Name { id: object::new(ctx), name: string::utf8(name_bytes) }
	}
}
```

Fungsi `fill_name` mengembalikan instance `Name`.

## Penutup

Fungsi adalah blok utama logika. Selanjutnya kita bahas visibility specifiers (private, public, entry) untuk memperdalam cara mendesain API module.